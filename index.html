<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sam's Notebook - Drawing & Highlighting (Modified)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Kalam:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Basic body and notebook styles */
        body {
            font-family: 'Inter', sans-serif;
            user-select: none; /* Prevent text selection during drag/draw */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            background-color: #f0fdf4; /* Light green background */
            /* Subtle dot grid background */
            background-image: radial-gradient(#a7f3d0 1px, transparent 1px), radial-gradient(#a7f3d0 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }

        .notebook-container {
            width: 100%;
            max-width: 80rem; /* Max width */
            height: 85vh; /* Viewport height */
            max-height: 700px; /* Max height */
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1500px; /* For 3D page turn effect */
            transition: all 0.3s ease;
        }

        .notebook {
            display: flex;
            width: 100%;
            height: 100%;
            background-color: #a7f3d0; /* Notebook cover color */
            box-shadow: 0 15px 40px rgba(0,0,0,0.2), 0 5px 10px rgba(0,0,0,0.1);
            border-radius: 0.5rem;
            overflow: hidden;
            position: relative;
            transform-style: preserve-3d; /* Needed for page turn */
            transition: box-shadow 0.3s ease;
        }

        .notebook:hover {
            box-shadow: 0 20px 50px rgba(0,0,0,0.25), 0 7px 15px rgba(0,0,0,0.15);
        }

        /* Page display styles */
        .page-display {
            flex: 1; /* Each page takes half the width */
            height: 100%;
            background-color: white;
            position: relative;
            border: 1px solid #d1d5db; /* Light gray border */
            overflow: hidden;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.8s ease; /* Page turn animation */
            backface-visibility: hidden; /* Hide back during flip */
        }

        #left-page {
            border-right: 2px solid #6ee7b7; /* Spine shadow */
            border-radius: 0.5rem 0 0 0.5rem;
            transform-origin: right center; /* Flip from right edge */
            box-shadow: inset -5px 0 10px rgba(0,0,0,0.03);
        }

        #right-page {
            border-radius: 0 0.5rem 0.5rem 0;
            transform-origin: left center; /* Flip from left edge */
            box-shadow: inset 5px 0 10px rgba(0,0,0,0.03);
        }

        /* Page flip animation classes */
        .page-flipping-out-left { transform: rotateY(-25deg); opacity: 0; }
        .page-flipping-in-left { transform: rotateY(25deg); opacity: 0; }
        .page-flipping-out-right { transform: rotateY(25deg); opacity: 0; }
        .page-flipping-in-right { transform: rotateY(-25deg); opacity: 0; }

        /* Page content area */
        .page-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            /* Lined paper effect */
            background-image: linear-gradient(to bottom, transparent 98%, #9ae6b4 98%);
            background-size: 100% 2em;
            font-family: 'Kalam', cursive; /* Handwriting font */
            padding: 1.5rem;
            overflow: auto; /* Scroll if content overflows */
            user-select: text; /* Allow text selection inside content */
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            scrollbar-width: thin;
            scrollbar-color: #6ee7b7 #f0fdf4;
            z-index: 1; /* Base layer */
        }

        .page-content::-webkit-scrollbar { width: 8px; }
        .page-content::-webkit-scrollbar-track { background: #f0fdf4; }
        .page-content::-webkit-scrollbar-thumb {
            background-color: #6ee7b7;
            border-radius: 10px;
            border: 2px solid #f0fdf4;
        }

        #page-data-storage { display: none; } /* Hidden storage for page templates */

        /* Styles for draggable/resizable elements */
        .scrapbook-element {
            position: absolute;
            cursor: grab;
            border: 1px dashed transparent;
            padding: 5px;
            min-width: 30px; /* Reduced min size slightly */
            min-height: 30px;
            background-color: rgba(255, 255, 255, 0.85); /* Slightly transparent background */
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10; /* Above page content and saved drawing */
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
            overflow: visible; /* Allow handles/buttons outside */
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        .scrapbook-element:hover,
        .scrapbook-element.selected {
            border-color: #34d399; /* Highlight border */
            z-index: 1000; /* Bring to front when interacting */
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .scrapbook-element.selected {
            box-shadow: 0 0 0 3px rgba(52, 211, 153, 0.3), 0 4px 8px rgba(0,0,0,0.15); /* Selection glow */
        }

        .scrapbook-element.dragging {
            cursor: grabbing;
            opacity: 0.85;
            z-index: 9999; /* Highest z-index while dragging */
            transform: scale(1.02);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        /* Text element styles */
        .scrapbook-text {
            font-family: 'Kalam', cursive;
            line-height: 1.5;
            outline: none;
            color: #1f2937;
            min-width: 100px;
            min-height: 1.5em;
            padding: 8px 10px;
            background-color: rgba(254, 252, 232, 0.9); /* Sticky note color */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-radius: 4px;
            user-select: text; /* Allow selecting text inside */
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            font-size: 16px;
            /* Ensure text wraps and is visible */
             white-space: normal;
             word-wrap: break-word;
             overflow-wrap: break-word;
             overflow: hidden; /* Hide overflow during resize */
        }

        .scrapbook-text:focus {
            background-color: rgba(254, 252, 232, 1);
            box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.5), 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Image element styles */
        .scrapbook-image {
            width: fit-content;
            height: fit-content;
            padding: 0;
            overflow: hidden;
            border-radius: 4px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .scrapbook-image:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.15);
        }

        .scrapbook-image img {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none; /* Prevent dragging image itself */
        }

        /* Shape element styles */
        .scrapbook-shape {
            background-color: rgba(52, 211, 153, 0.3); /* Semi-transparent green */
            border: 2px solid #34d399;
            padding: 0;
            overflow: hidden;
        }
        .scrapbook-shape.circle { border-radius: 50%; }
        .scrapbook-shape.line {
            background: none;
            border: none;
            height: 4px; /* Thickness of line */
            background-color: #34d399;
        }
        .scrapbook-shape.arrow::after { /* Arrowhead */
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 15px solid #34d399;
            top: -15px; /* Position above line end */
            right: 5px;
            transform: rotate(45deg);
        }

        /* Sticker element styles */
        .scrapbook-sticker {
            font-size: 40px;
            line-height: 1;
            background: none;
            border: none;
            padding: 5px;
            text-align: center;
            box-shadow: none;
        }

        /* Drawing canvas styles */
        #drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* Dimensions set by JS */
            display: none; /* Hidden by default */
            z-index: 1000; /* Above everything when drawing */
            cursor: crosshair;
            pointer-events: none; /* Only interactive when drawing mode is on */
        }
        /* Style for when drawing mode is active but no page targeted yet */
        body.drawing-mode-pending {
             cursor: crosshair; /* Indicate user should click a page */
        }

        /* Saved drawing display (image placeholder) */
        .saved-drawing {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5; /* Below scrapbook elements, above page content */
            pointer-events: none; /* Not interactive */
            display: none; /* Hidden by default */
            object-fit: contain; /* Ensure drawing fits */
        }


        /* Delete button on elements */
        .delete-button {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background-color: #ef4444; /* Red */
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            font-size: 14px;
            font-weight: bold;
            line-height: 21px; /* Center the '×' */
            text-align: center;
            cursor: pointer;
            z-index: 1001; /* Above the element */
            display: none; /* Hidden by default */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            opacity: 0;
            transform: scale(0.8);
        }

        .scrapbook-element:hover .delete-button,
        .scrapbook-element.selected .delete-button {
            display: block;
            opacity: 1;
            transform: scale(1);
        }

        .delete-button:hover {
            background-color: #dc2626; /* Darker red on hover */
            transform: scale(1.1);
        }

        /* Resize handles on elements */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #34d399; /* Green */
            border: 2px solid white;
            border-radius: 2px;
            z-index: 1002; /* Above delete button */
            display: none; /* Hidden by default */
            opacity: 0;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .scrapbook-element:hover .resize-handle,
        .scrapbook-element.selected .resize-handle {
            display: block;
            opacity: 1;
        }

        .resize-handle:hover {
            transform: scale(1.2);
            background-color: #10b981; /* Darker green */
        }

        /* Positioning and cursor for each handle */
        .resize-handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
        .resize-handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .resize-handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .resize-handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

        /* Cover page content styles */
        .cover-content {
            background-image: linear-gradient(to bottom right, #34d399, #10b981);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: inherit;
            font-family: 'Inter', sans-serif;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            box-shadow: inset 0 0 50px rgba(0,0,0,0.1);
        }
        .cover-content h1 { margin-bottom: 1rem; font-size: 2.5rem; }
        .frog-icon {
            font-size: 4rem;
            margin-top: 1rem;
            filter: drop-shadow(0 4px 4px rgba(0,0,0,0.2));
            animation: bounce 2s ease-in-out infinite;
        }
        @keyframes bounce { /* Frog animation */
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Controls container styles */
        .controls-container {
            @apply mt-8 flex flex-wrap justify-center items-center space-x-2 space-y-2 relative;
            padding: 0.75rem;
            background-color: rgba(255, 255, 255, 0.7); /* Semi-transparent white */
            border-radius: 1rem;
            backdrop-filter: blur(10px); /* Frosted glass effect */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .controls-container:hover {
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 6px 15px rgba(0,0,0,0.15);
        }

        /* General control button styles */
        .control-button {
            @apply px-4 py-2 bg-emerald-500 text-white rounded-lg shadow-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-opacity-75 transition duration-200 ease-in-out flex items-center justify-center;
            font-size: 0.9rem;
            font-weight: 500;
            min-width: 80px;
            line-height: 1.5;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden; /* For hover effect */
        }
        .control-button:not(:disabled) { @apply hover:bg-emerald-600; }
        .control-button:not(:disabled):active { transform: translateY(1px); }
        .control-button:disabled { @apply opacity-60 cursor-not-allowed shadow-md bg-emerald-400; }
        .control-button::before { /* Shine hover effect */
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: all 0.5s;
        }
        .control-button:not(:disabled):hover::before { left: 100%; }

        /* Specific style for add image button */
        #add-image-button {
            @apply p-3 bg-emerald-500 text-white rounded-lg shadow-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-opacity-75 transition duration-200 ease-in-out flex items-center justify-center;
            position: relative;
            overflow: hidden;
        }
        #add-image-button:not(:disabled) { @apply hover:bg-emerald-600; }
        #add-image-button:not(:disabled):active { transform: translateY(1px); }
        #add-image-button:disabled { @apply opacity-60 cursor-not-allowed shadow-md bg-emerald-400; }
        #add-image-button::before { /* Shine hover effect */
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: all 0.5s;
        }
        #add-image-button:not(:disabled):hover::before { left: 100%; }
        #add-image-button svg { width: 1.5em; height: 1.5em; flex-shrink: 0; }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            bottom: 120%; /* Position above the button */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            white-space: nowrap;
            z-index: 10000; /* Ensure tooltip is on top */
        }
        .tooltip::after { /* Arrow pointing down */
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
        }
        .tooltip-trigger:hover .tooltip {
            opacity: 1;
            transform: translateX(-50%) translateY(-5px); /* Slight upward move */
        }

        /* Placeholder page styles */
        .placeholder-page {
            background-color: #f0fdf4; /* Match body background */
            display: flex;
            justify-content: center;
            align-items: center;
            color: #a1a1aa; /* Gray text */
            font-style: italic;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Welcome instruction styles */
        .welcome-instructions {
            max-width: 250px;
            font-size: 0.9rem;
            line-height: 1.5;
            color: #374151;
            opacity: 0.8;
            background-color: rgba(255, 255, 255, 0.9) !important; /* Override default */
        }
        .first-note {
            background-color: rgba(254, 240, 138, 0.5) !important; /* Yellowish note */
            border-left: 3px solid #eab308 !important;
            box-shadow: 0 3px 8px rgba(0,0,0,0.08) !important;
        }

        #image-upload-input { display: none; } /* Hide file input */

        /* Modal styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Dim background */
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fff;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .modal-content h2 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #1f2937;
        }
        .modal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .modal-item {
            padding: 0.75rem;
            background-color: #f0fdf4;
            border: 2px solid #a7f3d0;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .modal-item:hover {
            background-color: #a7f3d0;
            border-color: #34d399;
        }
        /* Shape previews in modal */
        .modal-item.shape-circle::before { content: ''; display: block; width: 40px; height: 40px; margin: 0 auto; border-radius: 50%; background-color: #34d399; }
        .modal-item.shape-square::before { content: ''; display: block; width: 40px; height: 40px; margin: 0 auto; background-color: #34d399; }
        .modal-item.shape-line::before { content: ''; display: block; width: 40px; height: 4px; margin: 18px auto; background-color: #34d399; }
        .modal-item.shape-arrow::before { content: ''; display: block; width: 40px; height: 4px; margin: 18px auto; background-color: #34d399; position: relative; }
        .modal-item.shape-arrow::after { content: ''; position: absolute; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 12px solid #34d399; top: -4px; right: -8px; transform: rotate(45deg); }
        .modal-item.sticker { font-size: 2rem; line-height: 1; }
        .modal-close {
            @apply px-4 py-2 bg-gray-500 text-white rounded-lg shadow-lg hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75 transition duration-200 ease-in-out;
            margin-top: 1rem;
        }

        /* Drawing Controls */
        .drawing-controls {
            @apply flex flex-wrap items-center justify-center gap-3 mt-2; /* Increased gap */
            display: none; /* Hidden by default */
            padding: 0.75rem; /* Increased padding */
            background-color: rgba(255, 255, 255, 0.9); /* More opaque background */
            border-radius: 0.75rem; /* Slightly more rounded */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Slightly stronger shadow */
            max-width: 100%; /* Ensure it doesn't exceed container width */
            box-sizing: border-box; /* Include padding in width */
        }

        .drawing-controls button {
            @apply px-3 py-1 bg-emerald-500 text-white rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-opacity-75 transition duration-200 ease-in-out;
            font-size: 0.8rem;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .drawing-controls button:not(:disabled):hover { @apply bg-emerald-600; }
        .drawing-controls button:disabled { @apply opacity-60 cursor-not-allowed bg-emerald-400; }

        /* Brush size indicator styles */
        .brush-size {
            width: 28px; /* Slightly larger for touch */
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent; /* Placeholder for selected border */
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0; /* Prevent shrinking in flex container */
        }
        .brush-size:hover {
            transform: scale(1.1);
        }
        .brush-size::before {
            content: '';
            border-radius: 50%;
            background-color: #4b5563; /* Dark Gray - Visible on green */
            transition: all 0.2s ease;
        }
        .brush-size.small::before { width: 4px; height: 4px; }
        .brush-size.medium::before { width: 8px; height: 8px; }
        .brush-size.large::before { width: 12px; height: 12px; }
        .brush-size.selected {
            border-color: #fff; /* White border when selected */
            box-shadow: 0 0 0 2px #34d399; /* Green glow */
        }

        /* Color Palette styles */
        #color-palette {
            display: flex;
            flex-wrap: wrap; /* Allow colors to wrap */
            gap: 0.75rem; /* Increased space between color swatches */
            margin-right: 0.75rem; /* Increased space from brush size buttons */
            align-items: center;
            justify-content: center; /* Center swatches if they wrap */
        }

        .color-swatch {
            width: 28px; /* Slightly larger size for color swatch */
            height: 28px;
            border-radius: 50%; /* Make swatches circular */
            cursor: pointer;
            border: 2px solid #fff; /* White border */
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: transform 0.1s ease, border-color 0.2s ease;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        .color-swatch.selected {
            border-color: #34d399; /* Green border when selected */
            box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.5); /* Green glow */
        }

        /* Highlighter button selected state */
        #highlighter-button.selected {
            background-color: #10b981; /* Darker green when selected */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Style for highlighter icon button */
        #highlighter-button {
             @apply p-2; /* Adjust padding for icon */
             min-width: auto; /* Remove min-width */
        }
        #highlighter-button i {
             font-size: 1.2rem; /* Adjust icon size */
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .notebook-container { max-height: 600px; height: 70vh; }
            .controls-container { padding: 0.5rem; }
            .control-button { min-width: 70px; font-size: 0.8rem; padding: 0.375rem 0.75rem; }
            #add-image-button { padding: 0.375rem; }
            #add-image-button svg { width: 1.25em; height: 1.25em; }
            .page-content { padding: 1.25rem; }
            .modal-content { padding: 1rem; }
            .modal-grid { grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); }
            .modal-item { padding: 0.5rem; }
            .modal-item.shape-circle::before, .modal-item.shape-square::before { width: 30px; height: 30px; }
            .modal-item.shape-line::before, .modal-item.shape-arrow::before { width: 30px; margin: 13px auto; }
            .modal-item.sticker { font-size: 1.5rem; }
            .drawing-controls {
                 justify-content: center; /* Center items when wrapped */
                 gap: 0.75rem; /* Maintain gap */
                 padding: 0.5rem; /* Adjust padding */
            }
            .brush-size { width: 24px; height: 24px; }
            .color-swatch { width: 24px; height: 24px; } /* Slightly larger swatches on small screens */
        }
    </style>
</head>
<body class="bg-green-50 flex flex-col justify-center items-center min-h-screen p-4 overflow-hidden">

    <div class="notebook-container">
        <div class="notebook">
            <div id="left-page" class="page-display">
                </div>
            <div id="right-page" class="page-display">
                <div class="cover-content" id="cover-content-display">
                    <h1>Sam's Notebook</h1>
                    <div class="frog-icon">🐸</div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="image-upload-input" accept="image/*">

    <div class="controls-container">
        <button id="prev-page" class="control-button tooltip-trigger" disabled>
            <span class="tooltip">Previous Page</span>
            &lt; Prev
        </button>

        <button id="add-image-button" class="tooltip-trigger" title="Add Image from Device" disabled>
            <span class="tooltip">Add Image</span>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
            </svg>
        </button>
        <button id="add-shape-button" class="control-button tooltip-trigger" disabled>
            <span class="tooltip">Add Shape</span>
            Shape
        </button>
        <button id="add-sticker-button" class="control-button tooltip-trigger" disabled>
            <span class="tooltip">Add Sticker</span>
            Sticker
        </button>
        <button id="drawing-button" class="control-button tooltip-trigger" disabled>
            <span class="tooltip">Toggle Drawing</span>
            Draw
        </button>

        <button id="next-page" class="control-button tooltip-trigger">
            <span class="tooltip">Next Page</span>
            Next &gt;
        </button>

        <div id="drawing-controls" class="drawing-controls">
            <div id="color-palette">
                </div>

            <button id="brush-small" class="brush-size small tooltip-trigger">
                 <span class="tooltip">Small Brush (3px)</span>
            </button>
            <button id="brush-medium" class="brush-size medium selected tooltip-trigger">
                 <span class="tooltip">Medium Brush (6px)</span>
            </button>
            <button id="brush-large" class="brush-size large selected tooltip-trigger">
                 <span class="tooltip">Large Brush (10px)</span>
            </button>

            <button id="highlighter-button" class="tooltip-trigger">
                <span class="tooltip">Toggle Highlighter (20px)</span>
                <i class="fas fa-highlighter"></i> </button>

            <button id="undo-drawing" class="control-button tooltip-trigger" disabled>
                <span class="tooltip">Undo Last Stroke (Ctrl+Z)</span>
                Undo
            </button>

            <button id="clear-drawing" class="control-button tooltip-trigger">
                <span class="tooltip">Clear Page Drawing</span>
                Clear
            </button>
        </div>
    </div>

    <canvas id="drawing-canvas"></canvas>

    <div id="selector-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">Select an Item</h2>
            <div id="modal-grid" class="modal-grid"></div>
            <button id="modal-close" class="modal-close">Close</button>
        </div>
    </div>

    <div id="page-data-storage">
        <div class="page-content" data-page-number="0">
            <img class="saved-drawing" alt="Saved Drawing"> <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Inside Cover</h2>
            <div class="scrapbook-element scrapbook-text welcome-instructions" style="left: 50px; top: 70px; width: 250px; z-index: 10;" contenteditable="true">
                Welcome to your notebook! Click Next to start writing, adding images, shapes, stickers, or drawing.
            </div>
        </div>
        <div class="page-content" data-page-number="1">
             <img class="saved-drawing" alt="Saved Drawing">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 1</h2>
            <div class="scrapbook-element scrapbook-text welcome-instructions" style="left: 50px; top: 70px; width: 250px; z-index: 10;" contenteditable="true">
                • Double-click to add notes<br>
                • Drag elements to move them<br>
                • Use buttons to add images, shapes, stickers, or draw<br>
                • Try pasting text or images<br>
                • Click to edit, hover to delete
            </div>
            <div class="scrapbook-element scrapbook-text first-note" style="left: 50px; top: 180px; width: 200px; z-index: 11;" contenteditable="true">My first note! Click to edit or drag me around.</div>
        </div>
        <div class="page-content" data-page-number="2">
             <img class="saved-drawing" alt="Saved Drawing">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 2</h2>
        </div>
        <div class="page-content" data-page-number="3">
             <img class="saved-drawing" alt="Saved Drawing">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 3</h2>
            <div class="scrapbook-element scrapbook-image" style="left: 80px; top: 120px; width: 150px; height: 100px; z-index: 12;">
                <img src="https://placehold.co/150x100/e0e0e0/757575?text=Paste+Image" alt="Placeholder Image" onerror="this.src='https://placehold.co/150x100/e0e0e0/757575?text=Image+Error'">
            </div>
        </div>
        <div class="page-content" data-page-number="4">
             <img class="saved-drawing" alt="Saved Drawing">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 4</h2>
        </div>
        <div class="page-content" data-page-number="5">
             <img class="saved-drawing" alt="Saved Drawing">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 5</h2>
        </div>
        <div class="page-content" data-page-number="6">
             <img class="saved-drawing" alt="Saved Drawing">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Page 6</h2>
        </div>
        <div class="page-content" data-page-number="7">
             <img class="saved-drawing" alt="Saved Drawing">
            <h2 class="text-xl font-semibold mb-4 text-green-800 opacity-60 pointer-events-none absolute top-4 left-4">Inside Back Cover</h2>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const notebook = document.querySelector('.notebook');
            const leftPageDisplay = document.getElementById('left-page');
            const rightPageDisplay = document.getElementById('right-page');
            const pageDataStorage = document.getElementById('page-data-storage');
            const coverContentDisplay = document.getElementById('cover-content-display');
            const prevButton = document.getElementById('prev-page');
            const nextButton = document.getElementById('next-page');
            const addImageButton = document.getElementById('add-image-button');
            const addShapeButton = document.getElementById('add-shape-button');
            const addStickerButton = document.getElementById('add-sticker-button');
            const drawingButton = document.getElementById('drawing-button');
            const imageUploadInput = document.getElementById('image-upload-input');
            const drawingCanvas = document.getElementById('drawing-canvas');
            const drawingControls = document.getElementById('drawing-controls');
            // const colorPicker = document.getElementById('color-picker'); // Removed
            const colorPalette = document.getElementById('color-palette'); // New
            const brushSmall = document.getElementById('brush-small');
            const brushMedium = document.getElementById('brush-medium');
            const brushLarge = document.getElementById('brush-large');
            const highlighterButton = document.getElementById('highlighter-button');
            const undoDrawing = document.getElementById('undo-drawing');
            const clearDrawing = document.getElementById('clear-drawing');
            const selectorModal = document.getElementById('selector-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalGrid = document.getElementById('modal-grid');
            const modalClose = document.getElementById('modal-close');
            const body = document.body; // Reference to body for cursor style

            // --- State Variables ---
            const pages = Array.from(pageDataStorage.querySelectorAll('.page-content'))
                .sort((a, b) => parseInt(a.dataset.pageNumber) - parseInt(b.dataset.pageNumber));
            const totalPages = pages.length;
            let currentSpreadIndex = 0;
            let elementZIndex = 10;
            let draggedElement = null;
            let offsetX, offsetY;
            let dragStartX, dragStartY;
            let resizingElement = null;
            let resizeHandle = null;
            let startX, startY, startWidth, startHeight, startFontSize;
            let aspectRatio;
            let selectedElement = null;
            const animationDuration = 800;
            const baseFontSize = 16;
            const minSize = 30; // Minimum element size

            // --- Drawing State ---
            let isDrawingMode = false;
            let isDrawingModePending = false;
            let isHighlighterMode = false;
            let drawingContext = drawingCanvas.getContext('2d');
            let isDrawing = false;
            let lastX = 0, lastY = 0;
            const brushSizes = { small: 3, medium: 6, large: 10 };
            const highlighterSize = 20;
            let currentPenSize = brushSizes.medium;
            let currentBrushSize = currentPenSize;
            let pageDrawings = {};
            let activeDrawingPageNum = null;
            let currentDrawingStrokes = [];
            let pageTargetListener = null;
            let currentColor = '#ffff00'; // Default color (Yellow)

            // --- Data Definitions ---
            const shapes = [ { id: 'circle', name: 'Circle' }, { id: 'square', name: 'Square' }, { id: 'line', name: 'Line' } ];
            const stickers = ['😺', '🌟', '🍎', '🚀', '🎉', '💖', '💡', '🐸'];
            // Define colors for the palette
            const colors = [
                '#000000', // Black
                '#ff0000', // Red
                '#0000ff', // Blue
                '#34d399', // Green
                '#ffff00', // Yellow
                '#FFA500', // Orange
                '#FFB6C1', // Light Pink
                '#ADD8E6', // Light Blue
                '#98FB98', // Pale Green
                '#FFFFE0', // Light Yellow
                '#E6E6FA'  // Lavender
            ];


            // --- Initialization ---
            setBrushSizeUI(brushSizes.medium, brushMedium);
            populateColorPalette(); // Populate the color palette
            updateView();

            // --- Core Functions ---

            function populateColorPalette() {
                colorPalette.innerHTML = ''; // Clear existing
                colors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.classList.add('color-swatch');
                    swatch.style.backgroundColor = color;
                    swatch.dataset.color = color;
                    swatch.title = color; // Use hex code as tooltip for now
                    swatch.addEventListener('click', () => selectColor(color, swatch));
                    colorPalette.appendChild(swatch);
                });
                 // Select the default color swatch
                 const defaultSwatch = colorPalette.querySelector(`[data-color="${currentColor}"]`);
                 if(defaultSwatch) defaultSwatch.classList.add('selected');
            }

            function selectColor(color, selectedSwatch) {
                 currentColor = color;
                 // Remove selected class from all swatches
                 colorPalette.querySelectorAll('.color-swatch').forEach(swatch => {
                     swatch.classList.remove('selected');
                 });
                 // Add selected class to the clicked swatch
                 if(selectedSwatch) selectedSwatch.classList.add('selected');
                 if (isDrawingMode) configureDrawingContext(); // Update drawing context immediately
            }


            function updateView() {
                deselectElement();
                leftPageDisplay.innerHTML = '';
                rightPageDisplay.innerHTML = '';
                coverContentDisplay.style.display = 'none';
                if (isDrawingMode) deactivateDrawingMode(true);
                drawingCanvas.style.display = 'none';
                let leftPageContent = null, rightPageContent = null;
                let leftPageNum = -1, rightPageNum = -1;
                if (currentSpreadIndex === 0) {
                    leftPageContent = createPlaceholderPage("(Inside Cover)");
                    rightPageDisplay.appendChild(coverContentDisplay);
                    coverContentDisplay.style.display = 'flex';
                } else {
                    leftPageNum = (currentSpreadIndex - 1) * 2;
                    rightPageNum = leftPageNum + 1;
                    leftPageContent = (leftPageNum >= 0 && leftPageNum < totalPages) ? pages[leftPageNum].cloneNode(true) : createPlaceholderPage("(Blank)");
                    rightPageContent = (rightPageNum >= 0 && rightPageNum < totalPages) ? pages[rightPageNum].cloneNode(true) : createPlaceholderPage("(End)");
                }
                if (leftPageContent) {
                    leftPageDisplay.appendChild(leftPageContent);
                    if (leftPageNum !== -1 && !leftPageContent.classList.contains('placeholder-page')) {
                        attachScrapbookListeners(leftPageContent);
                        loadAndDisplaySavedDrawing(leftPageContent, leftPageNum);
                    }
                }
                if (rightPageContent && currentSpreadIndex !== 0) {
                    rightPageDisplay.appendChild(rightPageContent);
                     if (rightPageNum !== -1 && !rightPageContent.classList.contains('placeholder-page')) {
                        attachScrapbookListeners(rightPageContent);
                        loadAndDisplaySavedDrawing(rightPageContent, rightPageNum);
                    }
                }
                updateButtonStates();
            }

            function createPlaceholderPage(text) {
                const placeholder = document.createElement('div');
                placeholder.classList.add('page-content', 'placeholder-page');
                placeholder.textContent = text;
                const img = document.createElement('img');
                img.classList.add('saved-drawing');
                img.alt = "Saved Drawing Area";
                placeholder.appendChild(img);
                return placeholder;
            }

            function loadAndDisplaySavedDrawing(pageElement, pageNum) {
                const savedDrawingImg = pageElement.querySelector('.saved-drawing');
                if (!savedDrawingImg) return;
                const savedDataUrl = pageDrawings[pageNum];
                savedDrawingImg.src = savedDataUrl || '';
                savedDrawingImg.style.display = savedDataUrl ? 'block' : 'none';
            }

            function attachScrapbookListeners(pageElement) {
                if (!pageElement || pageElement.classList.contains('placeholder-page')) return;
                let maxZ = elementZIndex;
                pageElement.querySelectorAll('.scrapbook-element').forEach(el => {
                    const currentZ = parseInt(el.style.zIndex);
                    if (!isNaN(currentZ)) maxZ = Math.max(maxZ, currentZ);
                    if (!el.dataset.interactive) makeElementInteractive(el);
                });
                elementZIndex = maxZ;
                pageElement.addEventListener('dblclick', handlePageDoubleClick);
                pageElement.addEventListener('paste', handlePaste);
            }

            function handlePageDoubleClick(e) {
                const contentArea = e.currentTarget;
                if (e.target !== contentArea || contentArea.classList.contains('placeholder-page') || e.target.closest('.scrapbook-element')) return;
                deselectElement();
                const textElement = document.createElement('div');
                textElement.classList.add('scrapbook-element', 'scrapbook-text');
                textElement.setAttribute('contenteditable', 'true');
                textElement.textContent = 'Type here...';
                const rect = contentArea.getBoundingClientRect();
                const scrollX = contentArea.scrollLeft; const scrollY = contentArea.scrollTop;
                const x = e.clientX - rect.left + scrollX; const y = e.clientY - rect.top + scrollY;
                textElement.style.position = 'absolute';
                textElement.style.left = `${Math.max(0, x - 25)}px`;
                textElement.style.top = `${Math.max(0, y - 15)}px`;
                textElement.style.width = '150px';
                elementZIndex++; textElement.style.zIndex = elementZIndex;
                contentArea.appendChild(textElement);
                makeElementInteractive(textElement);
                selectElement(textElement);
                textElement.focus();
                const selection = window.getSelection(); const range = document.createRange();
                range.selectNodeContents(textElement);
                selection.removeAllRanges(); selection.addRange(range);
            }

            function handlePaste(e) {
                const contentArea = e.currentTarget;
                if (contentArea.classList.contains('placeholder-page')) return;
                e.preventDefault();
                const items = (e.clipboardData || window.clipboardData).items;
                for (const item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        const blob = item.getAsFile(); const reader = new FileReader();
                        reader.onload = (event) => addImageElement(event.target.result, contentArea);
                        reader.readAsDataURL(blob); break;
                    } else if (item.type === 'text/plain') {
                        item.getAsString(text => {
                            deselectElement();
                            const textElement = document.createElement('div');
                            textElement.classList.add('scrapbook-element', 'scrapbook-text');
                            textElement.setAttribute('contenteditable', 'true');
                            textElement.textContent = text;
                            const rect = contentArea.getBoundingClientRect();
                            const scrollX = contentArea.scrollLeft; const scrollY = contentArea.scrollTop;
                            const pasteX = scrollX + rect.width * 0.1 + Math.random() * 20;
                            const pasteY = scrollY + rect.height * 0.1 + Math.random() * 20;
                            textElement.style.position = 'absolute';
                            textElement.style.left = `${pasteX}px`; textElement.style.top = `${pasteY}px`;
                            textElement.style.width = '150px';
                            elementZIndex++; textElement.style.zIndex = elementZIndex;
                            contentArea.appendChild(textElement);
                            makeElementInteractive(textElement); selectElement(textElement);
                        }); break;
                    }
                }
            }

            function addControls(element) {
                if (element.querySelector('.delete-button')) return;
                const deleteBtn = document.createElement('div');
                deleteBtn.classList.add('delete-button'); deleteBtn.innerHTML = '×';
                deleteBtn.title = 'Delete Element';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); element.remove();
                    if (selectedElement === element) selectedElement = null;
                });
                element.appendChild(deleteBtn);
                ['nw', 'ne', 'sw', 'se'].forEach(handleType => {
                    const handle = document.createElement('div');
                    handle.classList.add('resize-handle', handleType);
                    handle.addEventListener('mousedown', onResizeHandleMouseDown);
                    element.appendChild(handle);
                });
            }

            function makeElementInteractive(element) {
                if (element.dataset.interactive) return;
                element.dataset.interactive = 'true';
                addControls(element);
                // Modified: Allow dragging for all scrapbook elements, including text.
                // The user-select: text CSS property on .scrapbook-text allows text selection.
                element.addEventListener('mousedown', onElementMouseDown);
                const img = element.querySelector('img');
                if (img) img.ondragstart = () => false;
            }

            function onElementMouseDown(e) {
                // Check if the click is on a resize handle or delete button, or if it's not the left mouse button
                if (e.button !== 0 || e.target.classList.contains('resize-handle') || e.target.classList.contains('delete-button')) {
                     return;
                }
                // Allow dragging for all scrapbook elements.
                // The user-select: text CSS property on .scrapbook-text handles text selection intent.
                const element = e.currentTarget;
                selectElement(element);
                draggedElement = element;
                const rect = draggedElement.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                document.addEventListener('mousemove', onDragMouseMove);
                document.addEventListener('mouseup', onDragMouseUp);
            }

            /**
             * Handles mouse movement during element dragging.
             * Moves the element and handles transferring between pages.
             * Adds 'dragging' class for visual feedback and z-index adjustment.
             * @param {MouseEvent} e - The mousemove event.
             */
            function onDragMouseMove(e) {
                if (!draggedElement) return;
                const dx = e.clientX - dragStartX; const dy = e.clientY - dragStartY;

                // Start dragging only after a small threshold to avoid accidental drags
                if (!draggedElement.classList.contains('dragging') && Math.sqrt(dx*dx + dy*dy) > 5) {
                    draggedElement.classList.add('dragging');
                    // Temporarily increase z-index while dragging
                    draggedElement.style.zIndex = 9999;
                }

                if (draggedElement.classList.contains('dragging')) {
                    e.preventDefault(); // Prevent default browser drag behavior (like image dragging)

                    let parent = draggedElement.parentElement;
                    const notebookRect = notebook.getBoundingClientRect();
                    const leftPageRect = leftPageDisplay.getBoundingClientRect();
                    const rightPageRect = rightPageDisplay.getBoundingClientRect();

                    let targetPage = parent; // Assume staying on the same page initially
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;

                    const leftPageContentEl = leftPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                    const rightPageContentEl = rightPageDisplay.querySelector('.page-content:not(.placeholder-page)');

                    // Check if mouse is over the left or right page content area
                    const isOverLeftPage = leftPageContentEl && mouseX >= leftPageRect.left && mouseX <= leftPageRect.right && mouseY >= notebookRect.top && mouseY <= notebookRect.bottom;
                    const isOverRightPage = rightPageContentEl && mouseX >= rightPageRect.left && mouseX <= rightPageRect.right && mouseY >= notebookRect.top && mouseY <= notebookRect.bottom;

                    // Determine if the element should move to the other page
                    if (isOverLeftPage && parent === rightPageContentEl) {
                        targetPage = leftPageContentEl;
                    } else if (isOverRightPage && parent === leftPageContentEl) {
                        targetPage = rightPageContentEl;
                    }

                    // If the target page is different, move the element
                    if (targetPage !== parent) {
                        const oldParentRect = parent.getBoundingClientRect();
                        const newParentRect = targetPage.getBoundingClientRect();

                        // Calculate the new position relative to the new parent
                        // Need to account for the parent's position and scroll offset
                        const currentX = parseFloat(draggedElement.style.left) || 0;
                        const currentY = parseFloat(draggedElement.style.top) || 0;

                        let newX = currentX + (oldParentRect.left - newParentRect.left) + parent.scrollLeft - targetPage.scrollLeft;
                        let newY = currentY + (oldParentRect.top - newParentRect.top) + parent.scrollTop - targetPage.scrollTop;

                        // Append the element to the new parent
                        targetPage.appendChild(draggedElement);
                        parent = targetPage; // Update parent reference

                        // Ensure the element stays within the new parent's bounds
                        newX = Math.max(0, Math.min(newX, parent.scrollWidth - draggedElement.offsetWidth));
                        newY = Math.max(0, Math.min(newY, parent.scrollHeight - draggedElement.offsetHeight));

                        // Apply the new position
                        draggedElement.style.left = `${newX}px`;
                        draggedElement.style.top = `${newY}px`;

                    } else {
                        // If staying on the same page, update position based on mouse movement
                        const parentRect = parent.getBoundingClientRect();
                        let x = e.clientX - parentRect.left - offsetX + parent.scrollLeft;
                        let y = e.clientY - parentRect.top - offsetY + parent.scrollTop;

                        // Ensure the element stays within the current parent's bounds
                        x = Math.max(0, Math.min(x, parent.scrollWidth - draggedElement.offsetWidth));
                        y = Math.max(0, Math.min(y, parent.scrollHeight - draggedElement.offsetHeight));

                        draggedElement.style.left = `${x}px`;
                        draggedElement.style.top = `${y}px`;
                    }
                }
            }

            function onDragMouseUp(e) {
                if (!draggedElement) return;

                const wasDragging = draggedElement.classList.contains('dragging');

                // Remove dragging class
                draggedElement.classList.remove('dragging');

                // Reset z-index after dragging, but keep selected element on top
                if (wasDragging) {
                    elementZIndex++; // Increment z-index for the dropped element
                    draggedElement.style.zIndex = elementZIndex;
                } else {
                     // If it was just a click (not a drag), keep the selected z-index or reset
                     if (selectedElement === draggedElement) {
                         // Keep the elevated z-index if it's still selected
                          draggedElement.style.zIndex = parseInt(draggedElement.style.zIndex || 1000);
                     } else {
                         // Otherwise, reset to a normal z-index range
                         draggedElement.style.zIndex = Math.max(10, parseInt(draggedElement.style.zIndex || 10) - 500);
                     }
                }


                // Clear the dragged element reference
                draggedElement = null;

                // Remove event listeners
                document.removeEventListener('mousemove', onDragMouseMove);
                document.removeEventListener('mouseup', onDragMouseUp);
            }

            function onResizeHandleMouseDown(e) {
                e.stopPropagation(); e.preventDefault();
                resizingElement = e.target.closest('.scrapbook-element');
                if (!resizingElement) return;
                resizeHandle = e.target; const img = resizingElement.querySelector('img');
                startX = e.clientX; startY = e.clientY;
                startWidth = resizingElement.offsetWidth; startHeight = resizingElement.offsetHeight;
                startFontSize = resizingElement.classList.contains('scrapbook-text') ? parseFloat(window.getComputedStyle(resizingElement).fontSize) : baseFontSize;
                aspectRatio = img ? img.naturalWidth / img.naturalHeight : (startWidth / startHeight);
                if (isNaN(aspectRatio) || aspectRatio <= 0) aspectRatio = 1;
                document.addEventListener('mousemove', onResizeMouseMove);
                document.addEventListener('mouseup', onResizeMouseUp);
            }

           /**
             * Handles mouse movement during element resizing.
             * Adjusts element dimensions and position based on handle dragged.
             * Maintains aspect ratio for images.
             * Scales font size for text elements.
             * **FIXED**: Corrected position calculation for nw/ne handles.
             * @param {MouseEvent} e - The mousemove event.
             */
           function onResizeMouseMove(e) {
                if (!resizingElement || !resizeHandle) return; e.preventDefault();
                const dx = e.clientX - startX; const dy = e.clientY - startY;
                const parent = resizingElement.parentElement; if (!parent) return;
                const parentWidth = parent.scrollWidth; const parentHeight = parent.scrollHeight;
                let originalLeft = parseFloat(resizingElement.style.left || 0);
                let originalTop = parseFloat(resizingElement.style.top || 0);
                let newWidth = startWidth; let newHeight = startHeight;
                let newLeft = originalLeft; let newTop = originalTop;
                const isImage = resizingElement.classList.contains('scrapbook-image');
                const isText = resizingElement.classList.contains('scrapbook-text');
                const isLine = resizingElement.classList.contains('scrapbook-shape') && resizingElement.classList.contains('line');

                // Calculate new dimensions based on handle and mouse delta
                if (resizeHandle.classList.contains('se')) { // Bottom-right
                    newWidth = startWidth + dx;
                    newHeight = isImage ? newWidth / aspectRatio : (isLine ? startHeight : startHeight + dy);
                } else if (resizeHandle.classList.contains('sw')) { // Bottom-left
                    newWidth = startWidth - dx;
                    newHeight = isImage ? newWidth / aspectRatio : (isLine ? startHeight : startHeight + dy);
                    // Left changes based on width change
                    // newLeft = originalLeft + dx; // Old incorrect way
                } else if (resizeHandle.classList.contains('ne')) { // Top-right
                    newWidth = startWidth + dx;
                    newHeight = isImage ? newWidth / aspectRatio : (isLine ? startHeight : startHeight - dy);
                    // Top changes based on height change
                    // newTop = originalTop + dy; // Old incorrect way
                } else if (resizeHandle.classList.contains('nw')) { // Top-left
                    newWidth = startWidth - dx;
                    newHeight = isImage ? newWidth / aspectRatio : (isLine ? startHeight : startHeight - dy);
                    // Both Left and Top change
                    // newLeft = originalLeft + dx; // Old incorrect way
                    // newTop = originalTop + dy; // Old incorrect way
                }

                // Enforce minimum size BEFORE calculating position changes for nw/ne/sw
                newWidth = Math.max(minSize, newWidth);
                newHeight = isLine ? startHeight : Math.max(minSize, newHeight);

                // --- POSITION FIX ---
                // Calculate position changes based on the *actual* change in dimensions
                if (resizeHandle.classList.contains('nw')) {
                    newLeft = originalLeft + (startWidth - newWidth);
                    newTop = originalTop + (startHeight - newHeight);
                } else if (resizeHandle.classList.contains('ne')) {
                    newTop = originalTop + (startHeight - newHeight);
                    // newLeft remains originalLeft
                } else if (resizeHandle.classList.contains('sw')) {
                    newLeft = originalLeft + (startWidth - newWidth);
                    // newTop remains originalTop
                }
                // For 'se', newLeft and newTop remain originalLeft/Top

                // --- BOUNDARY CHECKS ---
                // Check if calculated position/size goes out of bounds and adjust
                if (newLeft < 0) {
                    newWidth += newLeft; // Reduce width by the amount it went negative
                    newLeft = 0;
                }
                if (newTop < 0) {
                    newHeight += newTop; // Reduce height by the amount it went negative
                    newTop = 0;
                }
                if (newLeft + newWidth > parentWidth) {
                    newWidth = parentWidth - newLeft;
                }
                if (newTop + newHeight > parentHeight) {
                    newHeight = parentHeight - newTop;
                }

                // Re-enforce minimum size after boundary adjustments
                newWidth = Math.max(minSize, newWidth);
                newHeight = isLine ? startHeight : Math.max(minSize, newHeight);

                // --- ASPECT RATIO ADJUSTMENT (if needed after boundary checks) ---
                if (isImage) {
                    const expectedHeight = newWidth / aspectRatio;
                    const expectedWidth = newHeight * aspectRatio;

                    // If the aspect ratio is off significantly after boundary checks,
                    // adjust the *other* dimension and potentially the position again.
                    // Prioritize keeping the element within bounds.
                    if (Math.abs(expectedHeight - newHeight) > 1) { // Height differs from expected
                        if (expectedHeight < newHeight) { // Width was likely limited by boundary
                             newHeight = expectedHeight;
                             if (resizeHandle.classList.contains('ne') || resizeHandle.classList.contains('nw')) {
                                 newTop = originalTop + (startHeight - newHeight); // Recalculate top
                             }
                        } else { // Height was likely limited by boundary
                             newWidth = expectedWidth;
                              if (resizeHandle.classList.contains('sw') || resizeHandle.classList.contains('nw')) {
                                 newLeft = originalLeft + (startWidth - newWidth); // Recalculate left
                             }
                        }
                    }
                     // Re-check bounds after aspect ratio adjustment
                     if (newLeft < 0) { newWidth += newLeft; newLeft = 0; }
                     if (newTop < 0) { newHeight += newTop; newTop = 0; }
                     if (newLeft + newWidth > parentWidth) { newWidth = parentWidth - newLeft; }
                     if (newTop + newHeight > parentHeight) { newHeight = parentHeight - newTop; }
                     // Final min size check
                     newWidth = Math.max(minSize, newWidth);
                     newHeight = Math.max(minSize, newHeight);
                }


                // Apply final calculated styles
                resizingElement.style.width = `${newWidth}px`;
                resizingElement.style.height = `${newHeight}px`;
                resizingElement.style.left = `${newLeft}px`;
                resizingElement.style.top = `${newTop}px`;

                // Scale font size for text elements
                if (isText) {
                    const scaleFactor = Math.min(newWidth / startWidth, newHeight / startHeight); // Use min scale factor
                    const newFontSize = startFontSize * scaleFactor;
                    resizingElement.style.fontSize = `${Math.max(10, newFontSize)}px`; // Min font size 10px
                }
            }


            function onResizeMouseUp(e) {
                if (!resizingElement) return;
                resizingElement = null; resizeHandle = null;
                document.removeEventListener('mousemove', onResizeMouseMove);
                document.removeEventListener('mouseup', onResizeMouseUp);
            }

            function selectElement(element) {
                if (selectedElement && selectedElement !== element) {
                    selectedElement.classList.remove('selected');
                    // Reset z-index to a normal range if it was selected
                    selectedElement.style.zIndex = Math.max(10, parseInt(selectedElement.style.zIndex || 510) - 500);
                }
                if (element) {
                    element.classList.add('selected');
                    selectedElement = element;
                    // Elevate z-index when selected
                    element.style.zIndex = parseInt(element.style.zIndex || 10) + 500;
                }
            }

            function deselectElement() {
                if (selectedElement) {
                    selectedElement.classList.remove('selected');
                     // Reset z-index when deselected
                    selectedElement.style.zIndex = Math.max(10, parseInt(selectedElement.style.zIndex || 510) - 500);
                    selectedElement = null;
                }
            }

            document.addEventListener('click', (e) => {
                // Check if the click is outside any scrapbook element, modal, or controls
                if (!e.target.closest('.scrapbook-element') &&
                    !e.target.closest('.modal-content') &&
                    !e.target.closest('.controls-container') &&
                    !e.target.closest('.drawing-controls'))
                {
                    deselectElement();
                    selectorModal.style.display = 'none';
                }
            });

            function moveVisibleContentToStorage() {
                const leftContent = leftPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                if (leftContent) pageDataStorage.appendChild(leftContent);
                const rightContent = rightPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                if (rightContent) pageDataStorage.appendChild(rightContent);
            }

            function updateButtonStates() {
                prevButton.disabled = currentSpreadIndex <= 0;
                const lastPageNumber = totalPages - 1;
                const rightVisiblePageNum = (currentSpreadIndex - 1) * 2 + 1;
                nextButton.disabled = rightVisiblePageNum >= lastPageNumber && currentSpreadIndex !== 0;

                const leftPage = leftPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                const rightPage = rightPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                const canAddElements = currentSpreadIndex !== 0 && (leftPage || rightPage);

                addImageButton.disabled = !canAddElements;
                addShapeButton.disabled = !canAddElements;
                addStickerButton.disabled = !canAddElements;
                drawingButton.disabled = !canAddElements;

                 // Update tooltips based on disabled state
                 const disabledReason = currentSpreadIndex === 0 ? "Actions unavailable on cover" : "Navigate to a page first";
                 addImageButton.title = addImageButton.disabled ? disabledReason : "Add Image from Device";
                 addShapeButton.title = addShapeButton.disabled ? disabledReason : "Add Shape";
                 addStickerButton.title = addStickerButton.disabled ? disabledReason : "Add Sticker";
                 drawingButton.title = drawingButton.disabled ? disabledReason : "Toggle Drawing Mode";
            }

            function performPageTurn(direction) {
                deselectElement();
                const outLeftClass = direction > 0 ? 'page-flipping-out-left' : 'page-flipping-in-left';
                const outRightClass = direction > 0 ? 'page-flipping-out-right' : 'page-flipping-in-right';

                // Add classes to start the flip animation
                leftPageDisplay.classList.add(outLeftClass);
                rightPageDisplay.classList.add(outRightClass);

                // Disable buttons during animation
                prevButton.disabled = true;
                nextButton.disabled = true;
                addImageButton.disabled = true; // Disable other controls too
                addShapeButton.disabled = true;
                addStickerButton.disabled = true;
                drawingButton.disabled = true; // Disable drawing toggle during flip

                // Wait for half the animation duration before changing content
                setTimeout(() => {
                    moveVisibleContentToStorage(); // Save current page content
                    currentSpreadIndex += direction; // Update page index
                    updateView(); // Load new page content

                    // Add classes to start the incoming page animation
                    const inLeftClass = direction > 0 ? 'page-flipping-in-left' : 'page-flipping-out-left';
                    const inRightClass = direction > 0 ? 'page-flipping-in-right' : 'page-flipping-out-right';
                    leftPageDisplay.classList.add(inLeftClass);
                    rightPageDisplay.classList.add(inRightClass);

                    // Force reflow to ensure animation plays
                    void leftPageDisplay.offsetWidth;

                    // Remove animation classes after a short delay to allow animation to start
                    setTimeout(() => {
                        leftPageDisplay.classList.remove(inLeftClass);
                        rightPageDisplay.classList.remove(inRightClass);
                        leftPageDisplay.classList.remove(outLeftClass);
                        rightPageDisplay.classList.remove(outRightClass);
                         // Re-enable buttons after animation is complete
                        updateButtonStates();
                    }, animationDuration / 2); // Remove classes after the second half of animation
                }, animationDuration / 2); // Change content halfway through animation
            }

            // --- Element Creation Functions ---

            function addImageElement(imageDataUrl, targetPageElement) {
                if (!targetPageElement || targetPageElement.classList.contains('placeholder-page')) return;
                deselectElement();
                const imgElementContainer = document.createElement('div');
                imgElementContainer.classList.add('scrapbook-element', 'scrapbook-image');
                const img = document.createElement('img');
                img.src = imageDataUrl;
                img.alt = "User Added Image"; // Add alt text
                img.onerror = function() {
                    console.error("Failed to load image:", imageDataUrl.substring(0, 50) + "...");
                    // Replace with a placeholder image on error
                     img.src = `https://placehold.co/150x100/fecaca/991b1b?text=Load\\nError`;
                     img.alt = "Image load error";
                };
                imgElementContainer.appendChild(img);

                // Position the new image element
                const pasteX = targetPageElement.scrollLeft + targetPageElement.offsetWidth * 0.1 + Math.random() * 20;
                const pasteY = targetPageElement.scrollTop + targetPageElement.offsetHeight * 0.1 + Math.random() * 20;
                imgElementContainer.style.position = 'absolute';
                imgElementContainer.style.left = `${pasteX}px`;
                imgElementContainer.style.top = `${pasteY}px`;

                // Set initial z-index
                elementZIndex++;
                imgElementContainer.style.zIndex = elementZIndex;

                // Adjust size after image loads to maintain aspect ratio
                img.onload = () => {
                    const maxWidth = 200;
                    const maxHeight = 200;
                    let width = img.naturalWidth;
                    let height = img.naturalHeight;

                    // Provide default size if natural dimensions are zero or invalid
                    if (!width || !height) { width = 150; height = 100; }

                    // Scale down if larger than max dimensions
                    if (width > maxWidth || height > maxHeight) {
                        const scale = Math.min(maxWidth / width, maxHeight / height);
                        width *= scale;
                        height *= scale;
                    }

                    imgElementContainer.style.width = `${width}px`;
                    imgElementContainer.style.height = `${height}px`;

                    // Make the element interactive after loading and sizing
                    if (!imgElementContainer.dataset.interactive) {
                         makeElementInteractive(imgElementContainer);
                         selectElement(imgElementContainer); // Select the new element
                    }
                };

                // Append to the target page
                targetPageElement.appendChild(imgElementContainer);

                 // Make interactive immediately if image is already complete (cached)
                 if (img.complete) {
                     makeElementInteractive(imgElementContainer);
                     selectElement(imgElementContainer);
                 }
            }

            function addShapeElement(shapeType, targetPage) {
                if (!targetPage || targetPage.classList.contains('placeholder-page')) return;
                deselectElement();
                const shapeElement = document.createElement('div');
                shapeElement.classList.add('scrapbook-element', 'scrapbook-shape', shapeType);
                const pasteX = targetPage.scrollLeft + targetPage.offsetWidth * 0.1 + Math.random() * 20;
                const pasteY = targetPage.scrollTop + targetPage.offsetHeight * 0.1 + Math.random() * 20;
                shapeElement.style.position = 'absolute';
                shapeElement.style.left = `${pasteX}px`;
                shapeElement.style.top = `${pasteY}px`;
                shapeElement.style.width = shapeType === 'line' ? '100px' : '50px';
                shapeElement.style.height = shapeType === 'line' ? '4px' : '50px';
                elementZIndex++;
                shapeElement.style.zIndex = elementZIndex;
                targetPage.appendChild(shapeElement);
                makeElementInteractive(shapeElement);
                selectElement(shapeElement);
            }

            function addStickerElement(sticker, targetPage) {
                if (!targetPage || targetPage.classList.contains('placeholder-page')) return;
                deselectElement();
                const stickerElement = document.createElement('div');
                stickerElement.classList.add('scrapbook-element', 'scrapbook-sticker');
                stickerElement.textContent = sticker;
                const pasteX = targetPage.scrollLeft + targetPage.offsetWidth * 0.1 + Math.random() * 20;
                const pasteY = targetPage.scrollTop + targetPage.offsetHeight * 0.1 + Math.random() * 20;
                stickerElement.style.position = 'absolute';
                stickerElement.style.left = `${pasteX}px`;
                stickerElement.style.top = `${pasteY}px`;
                stickerElement.style.width = 'auto'; // Stickers size based on content
                stickerElement.style.height = 'auto';
                elementZIndex++;
                stickerElement.style.zIndex = elementZIndex;
                targetPage.appendChild(stickerElement);
                makeElementInteractive(stickerElement);
                selectElement(stickerElement);
            }

            // --- Modal Functions ---

            function showSelectorModal(type, callback) {
                // Determine the target page (prefer right, then left)
                let targetPage = rightPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                if (!targetPage) {
                    targetPage = leftPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                }
                // If no valid page, don't show modal
                if (!targetPage) return;

                modalTitle.textContent = type === 'shape' ? 'Select a Shape' : 'Select a Sticker';
                modalGrid.innerHTML = ''; // Clear previous items

                const items = type === 'shape' ? shapes : stickers;

                items.forEach(item => {
                    const div = document.createElement('div');
                    div.classList.add('modal-item', type === 'shape' ? `shape-${item.id || item}` : 'sticker'); // Add class for styling/preview
                    if (type === 'shape') {
                        div.textContent = item.name;
                        div.dataset.value = item.id; // Store shape ID
                    } else {
                        div.textContent = item; // Sticker emoji
                        div.dataset.value = item; // Store sticker emoji
                    }

                    // Add click listener to add the selected item
                    div.addEventListener('click', () => {
                        callback(div.dataset.value, targetPage); // Pass value and target page
                        selectorModal.style.display = 'none'; // Close modal
                    });

                    modalGrid.appendChild(div);
                });

                selectorModal.style.display = 'flex'; // Show the modal
            }

            // --- Drawing Functions ---

            function toggleDrawingMode() {
                if (drawingButton.disabled) return; // Prevent toggle if button is disabled

                if (isDrawingMode) {
                    // Deactivate drawing mode if currently active
                    deactivateDrawingMode(true); // Save drawing on deactivate
                } else {
                    // Activate drawing mode pending state
                    isDrawingModePending = true;
                    body.classList.add('drawing-mode-pending'); // Change cursor on body
                    drawingButton.classList.add('bg-emerald-600'); // Indicate active state
                    drawingButton.textContent = "Click Page"; // Prompt user to click a page
                    drawingControls.style.display = 'flex'; // Show drawing controls

                    // Add listener to capture the first click/touch on a page
                    pageTargetListener = (e) => handlePageTargeting(e);
                    notebook.addEventListener('mousedown', pageTargetListener);
                    notebook.addEventListener('touchstart', pageTargetListener, { passive: false });
                }
            }

            function handlePageTargeting(e) {
                if (!isDrawingModePending) return; // Only handle if pending

                 const clickedPage = e.target.closest('.page-content:not(.placeholder-page)');

                 if (clickedPage) {
                     e.preventDefault(); // Prevent default touch/click behavior

                     const pageNum = parseInt(clickedPage.dataset.pageNumber);

                     if (!isNaN(pageNum)) {
                         // Remove the temporary listener
                         notebook.removeEventListener('mousedown', pageTargetListener);
                         notebook.removeEventListener('touchstart', pageTargetListener);
                         pageTargetListener = null; // Clear listener reference
                         body.classList.remove('drawing-mode-pending'); // Reset cursor

                         // Activate drawing mode on the selected page
                         activateDrawingMode(clickedPage, pageNum);

                         // Simulate the initial click/touch to start drawing immediately
                         startDrawing(e);
                     }
                 }
            }


            function activateDrawingMode(targetPageElement, targetPageNum) {
                if (!targetPageElement) return;

                isDrawingModePending = false; // No longer pending
                isDrawingMode = true; // Drawing mode is now active
                activeDrawingPageNum = targetPageNum; // Set the page number being drawn on

                drawingButton.textContent = "Stop Draw"; // Change button text

                // Position and size the canvas over the target page
                const pageRect = targetPageElement.getBoundingClientRect();
                const notebookRect = notebook.getBoundingClientRect(); // Get notebook position for relative canvas positioning

                drawingCanvas.style.position = 'absolute';
                drawingCanvas.style.top = `${pageRect.top - notebookRect.top}px`; // Position relative to notebook
                drawingCanvas.style.left = `${pageRect.left - notebookRect.left}px`;
                drawingCanvas.width = pageRect.width; // Set canvas drawing surface size
                drawingCanvas.height = pageRect.height;
                drawingCanvas.style.width = `${pageRect.width}px`; // Set canvas display size
                drawingCanvas.style.height = `${pageRect.height}px`;

                // Configure the drawing context (color, size, alpha)
                configureDrawingContext();

                // Clear the canvas and load any saved drawing for this page
                drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                const savedDataUrl = pageDrawings[activeDrawingPageNum];
                currentDrawingStrokes = []; // Reset strokes for the new drawing session
                undoDrawing.disabled = true; // Disable undo initially

                if (savedDataUrl) {
                    const img = new Image();
                    img.onload = () => {
                        drawingContext.drawImage(img, 0, 0); // Draw the saved image onto the canvas
                    };
                    img.src = savedDataUrl; // Load the saved drawing
                }

                // Hide the saved drawing image element on the page
                const savedDrawingImg = targetPageElement.querySelector('.saved-drawing');
                if (savedDrawingImg) savedDrawingImg.style.display = 'none';

                // Show the canvas and make it interactive
                drawingCanvas.style.display = 'block';
                drawingCanvas.style.zIndex = 1000; // Ensure canvas is above page content
                drawingCanvas.style.pointerEvents = 'auto'; // Allow mouse/touch events on canvas
            }

            function configureDrawingContext() {
                if (!drawingContext) return;
                drawingContext.strokeStyle = currentColor; // Use the selected color
                drawingContext.lineWidth = currentBrushSize;
                // Decreased opacity for highlighter mode (from 0.3 to 0.15)
                drawingContext.globalAlpha = isHighlighterMode ? 0.15 : 1.0;
                drawingContext.lineCap = 'round';
                drawingContext.lineJoin = 'round';
            }

            function deactivateDrawingMode(save = true) {
                 // Handle pending state cancellation
                 if (isDrawingModePending) {
                     isDrawingModePending = false;
                     if (pageTargetListener) {
                        notebook.removeEventListener('mousedown', pageTargetListener);
                        notebook.removeEventListener('touchstart', pageTargetListener);
                        pageTargetListener = null;
                     }
                     body.classList.remove('drawing-mode-pending');
                     drawingButton.classList.remove('bg-emerald-600');
                     drawingButton.textContent = "Draw";
                     drawingControls.style.display = 'none';
                     return; // Exit if only pending state was active
                 }

                if (!isDrawingMode) return; // Do nothing if not in drawing mode

                if (save && activeDrawingPageNum !== null) {
                    // Save the current canvas drawing as a data URL
                    const currentDataUrl = drawingCanvas.toDataURL('image/png');

                    // Create a blank canvas to compare against (to check if anything was drawn)
                    const blankCanvas = document.createElement('canvas');
                    blankCanvas.width = drawingCanvas.width;
                    blankCanvas.height = drawingCanvas.height;
                    const blankDataUrl = blankCanvas.toDataURL('image/png');

                    // Find the corresponding saved drawing image element on the page
                    const pageElement = document.querySelector(`.page-content[data-page-number="${activeDrawingPageNum}"]`);
                    const savedDrawingImg = pageElement ? pageElement.querySelector('.saved-drawing') : null;

                    // If the canvas is not blank, save the drawing and display the image
                    if (currentDataUrl !== blankDataUrl) {
                         pageDrawings[activeDrawingPageNum] = currentDataUrl; // Store the drawing
                         if (savedDrawingImg) {
                             savedDrawingImg.src = currentDataUrl;
                             savedDrawingImg.style.display = 'block'; // Show the saved image
                         }
                    } else {
                        // If the canvas is blank, remove any saved drawing for this page
                        delete pageDrawings[activeDrawingPageNum];
                         if (savedDrawingImg) {
                             savedDrawingImg.src = ''; // Clear the image source
                             savedDrawingImg.style.display = 'none'; // Hide image
                         }
                    }
                }

                // Reset drawing state variables
                isDrawingMode = false;
                activeDrawingPageNum = null;
                currentDrawingStrokes = []; // Clear strokes for the next drawing session

                // Reset button text and hide controls
                drawingButton.classList.remove('bg-emerald-600');
                drawingButton.textContent = "Draw";
                drawingControls.style.display = 'none';

                // Hide and disable the canvas
                drawingCanvas.style.display = 'none';
                drawingCanvas.style.zIndex = 5; // Reset z-index
                drawingCanvas.style.pointerEvents = 'none'; // Disable interaction
            }

            function toggleHighlighterMode() {
                isHighlighterMode = !isHighlighterMode;
                highlighterButton.classList.toggle('selected', isHighlighterMode);

                // Set brush size based on mode
                currentBrushSize = isHighlighterMode ? highlighterSize : currentPenSize;

                // Update drawing context immediately if drawing mode is active
                if (isDrawingMode) configureDrawingContext();
            }

            function startDrawing(e) {
                if (!isDrawingMode || isDrawingModePending) return; // Only start if in active drawing mode
                e.preventDefault(); // Prevent scrolling/default touch actions

                isDrawing = true;
                const pos = getCanvasPos(e); // Get mouse/touch position relative to canvas
                lastX = pos.x;
                lastY = pos.y;

                configureDrawingContext(); // Apply current color, size, and alpha

                 // Start a new stroke
                 currentDrawingStrokes.push({
                     points: [{ x: lastX, y: lastY }],
                     color: drawingContext.strokeStyle,
                     size: drawingContext.lineWidth,
                     alpha: drawingContext.globalAlpha
                 });

                drawingContext.beginPath();
                drawingContext.moveTo(lastX, lastY);
            }

            function draw(e) {
                if (!isDrawing || !isDrawingMode || isDrawingModePending) return; // Only draw if drawing is active
                e.preventDefault(); // Prevent scrolling/default touch actions

                const pos = getCanvasPos(e); // Get current mouse/touch position
                const currentX = pos.x;
                const currentY = pos.y;

                 // Add the current point to the last stroke
                 const currentStrokeData = currentDrawingStrokes[currentDrawingStrokes.length - 1];
                 if (currentStrokeData) {
                     currentStrokeData.points.push({ x: currentX, y: currentY });
                 }

                drawingContext.lineTo(currentX, currentY);
                drawingContext.stroke();

                // Update last position
                lastX = currentX;
                lastY = currentY;
            }

            function stopDrawing() {
                if (!isDrawing || !isDrawingMode) return; // Only stop if drawing was active
                isDrawing = false;
                 // Enable undo button if there are strokes
                undoDrawing.disabled = currentDrawingStrokes.length === 0;
            }

            function getCanvasPos(e) {
                const rect = drawingCanvas.getBoundingClientRect();
                let clientX, clientY;

                // Handle both mouse and touch events
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                // Calculate position relative to the canvas
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            function undoLastStroke() {
                if (currentDrawingStrokes.length === 0 || !isDrawingMode) return;

                // Remove the last stroke from the array
                currentDrawingStrokes.pop();

                // Clear the canvas
                drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);

                // Reload the saved background image (if any)
                const savedDataUrl = pageDrawings[activeDrawingPageNum];
                let backgroundPromise = Promise.resolve(); // Use a promise to handle async image loading

                if (savedDataUrl) {
                    backgroundPromise = new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            drawingContext.drawImage(img, 0, 0);
                            resolve(); // Resolve promise after image is drawn
                        };
                         img.onerror = () => {
                             console.error("Error loading background for undo.");
                             resolve(); // Resolve even on error to continue
                         }
                        img.src = savedDataUrl;
                    });
                }

                // After the background is loaded (or if there's none), redraw the remaining strokes
                backgroundPromise.then(() => {
                    redrawCurrentStrokes();
                    // Disable undo if no strokes are left
                    undoDrawing.disabled = currentDrawingStrokes.length === 0;
                });
            }

            function redrawCurrentStrokes() {
                 // Redraw all strokes in the currentDrawingStrokes array
                 currentDrawingStrokes.forEach(stroke => {
                    drawingContext.beginPath();
                    drawingContext.strokeStyle = stroke.color; // Use stroke's saved color
                    drawingContext.lineWidth = stroke.size;   // Use stroke's saved size
                    drawingContext.globalAlpha = stroke.alpha; // Use stroke's saved alpha
                    drawingContext.lineCap = 'round';
                    drawingContext.lineJoin = 'round';

                    stroke.points.forEach((point, index) => {
                        if (index === 0) drawingContext.moveTo(point.x, point.y);
                        else drawingContext.lineTo(point.x, point.y);
                    });
                    drawingContext.stroke();
                });
                 // Reset the context alpha to the current mode's setting after redrawing
                 drawingContext.globalAlpha = isHighlighterMode ? 0.15 : 1.0;
            }


            function clearCanvas() {
                if (!isDrawingMode || activeDrawingPageNum === null) return; // Only clear if in drawing mode

                // Clear the canvas visually
                drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);

                // Clear the stroke data and disable undo
                currentDrawingStrokes = [];
                undoDrawing.disabled = true;

                // Remove the saved drawing data for this page
                delete pageDrawings[activeDrawingPageNum];

                // Hide the saved drawing image element on the page
                const pageElement = document.querySelector(`.page-content[data-page-number="${activeDrawingPageNum}"]`);
                if (pageElement) {
                    const savedDrawingImg = pageElement.querySelector('.saved-drawing');
                    if (savedDrawingImg) {
                         savedDrawingImg.src = ''; // Clear image source
                         savedDrawingImg.style.display = 'none'; // Hide image
                    }
                }
            }

            function setBrushSizeUI(size, selectedButton) {
                currentPenSize = size;
                // Update currentBrushSize only if not in highlighter mode
                if (!isHighlighterMode) {
                    currentBrushSize = currentPenSize;
                    if (isDrawingMode) configureDrawingContext(); // Update context if drawing
                }

                // Update UI to show selected brush size
                [brushSmall, brushMedium, brushLarge].forEach(btn => {
                    btn.classList.toggle('selected', btn === selectedButton);
                });
            }

            // --- Event Listeners ---
            prevButton.addEventListener('click', () => performPageTurn(-1));
            nextButton.addEventListener('click', () => performPageTurn(1));

            // Image upload listener
            addImageButton.addEventListener('click', () => { if (!addImageButton.disabled) imageUploadInput.click(); });
             imageUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        // Determine the target page (prefer right, then left)
                        let targetPage = rightPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                        if (!targetPage) {
                            targetPage = leftPageDisplay.querySelector('.page-content:not(.placeholder-page)');
                        }
                        // Add the image if a valid page is found
                        if (targetPage) addImageElement(event.target.result, targetPage);
                        else console.error("No valid page to add image to.");
                    };
                    reader.readAsDataURL(file);
                } else if (file) {
                    // Show an alert if the selected file is not an image
                    // Using a simple alert for now, could replace with a custom modal later
                    alert("Please select a valid image file.");
                }
                // Clear the file input value so the same file can be selected again
                e.target.value = null;
            });

            // Modal trigger buttons
            addShapeButton.addEventListener('click', () => { if (!addShapeButton.disabled) showSelectorModal('shape', addShapeElement); });
            addStickerButton.addEventListener('click', () => { if (!addStickerButton.disabled) showSelectorModal('sticker', addStickerElement); });
            modalClose.addEventListener('click', () => { selectorModal.style.display = 'none'; });

            // Drawing mode toggle
            drawingButton.addEventListener('click', toggleDrawingMode);

            // Color palette listener (handled by selectColor function)
            // colorPicker.addEventListener('change', () => { if (isDrawingMode) configureDrawingContext(); }); // Removed

            // Brush size button listeners
            brushSmall.addEventListener('click', () => setBrushSizeUI(brushSizes.small, brushSmall));
            brushMedium.addEventListener('click', () => setBrushSizeUI(brushSizes.medium, brushMedium));
            brushLarge.addEventListener('click', () => setBrushSizeUI(brushSizes.large, brushLarge));

            // Highlighter toggle
            highlighterButton.addEventListener('click', toggleHighlighterMode);

            // Undo and Clear drawing buttons
            undoDrawing.addEventListener('click', undoLastStroke);
            clearDrawing.addEventListener('click', clearCanvas);

            // Drawing canvas event listeners (mouse and touch)
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseleave', stopDrawing); // Stop drawing if mouse leaves canvas

            drawingCanvas.addEventListener('touchstart', startDrawing, { passive: false }); // passive: false to allow preventDefault
            drawingCanvas.addEventListener('touchmove', draw, { passive: false });
            drawingCanvas.addEventListener('touchend', stopDrawing);
            drawingCanvas.addEventListener('touchcancel', stopDrawing); // Stop drawing if touch is interrupted

            // Global keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                 // Ignore shortcuts if typing in a contenteditable element or input
                 if (e.target.closest('[contenteditable="true"]') || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                     // Allow Backspace/Delete to delete a selected element IF the focus is NOT inside the element's text
                     if ((e.key === 'Backspace' || e.key === 'Delete') && selectedElement && document.activeElement !== selectedElement && !selectedElement.contains(document.activeElement)) {
                         e.preventDefault(); // Prevent default browser back/delete action
                         selectedElement.remove();
                         selectedElement = null;
                     }
                     return; // Exit function if typing
                 }

                // Page navigation with arrow keys
                if (e.key === 'ArrowLeft' && !prevButton.disabled) {
                    e.preventDefault(); // Prevent default scroll
                    performPageTurn(-1);
                } else if (e.key === 'ArrowRight' && !nextButton.disabled) {
                    e.preventDefault(); // Prevent default scroll
                    performPageTurn(1);
                }
                 // Delete selected element with Backspace or Delete key
                 else if ((e.key === 'Backspace' || e.key === 'Delete') && selectedElement) {
                     e.preventDefault(); // Prevent default browser back/delete action
                     selectedElement.remove();
                     selectedElement = null;
                 }
                 // Close modal with Escape key
                 else if (e.key === 'Escape' && selectorModal.style.display === 'flex') {
                     selectorModal.style.display = 'none';
                 }
                 // Undo drawing with Ctrl+Z (or Cmd+Z on Mac)
                 else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && isDrawingMode && !undoDrawing.disabled) {
                     e.preventDefault(); // Prevent default undo action
                     undoLastStroke();
                 }
            });

        }); // End DOMContentLoaded
    </script>
</body>
</html>
